#!/usr/bin/env python

__usage__ = "lvalert_libraryTestsMP [--options]"
__description__ = """\
a series of tests to demonstrate functionality of each aspect of lvalertMP including

  - lvalertMPutils
  - commands
  - parseAlert

We should also test lvalert_listenMP and lvalert_commandMP (but that is not included in this script).
We note that interactiveQueue is "tested" in lvalert_sanityChecksMP because it requires human feedback (eg, checking that emails were sent)
"""
__author__ = "Reed Essick (reed.essick@ligo.org)"

#-------------------------------------------------

import os

from lvalertMP.lvalert import interactiveQueue
from lvalertMP.lvalert import commands
from lvalertMP.lvalert import lvalertMPutils as utils
from lvalertMP.lvalert import parseAlert

import time

import numpy as np

import json
import logging

from optparse import OptionParser

#-------------------------------------------------

parser = OptionParser(usage=__usage__, description=__description__)

parser.add_option('-v', '--verbose', default=False, action='store_true')
parser.add_option('-V', '--Verbose', default=False, action='store_true')

parser.add_option('', '--logDir', default='.', type='string')
parser.add_option('', '--logLevel', default=5, type='float')

### options about what to test
parser.add_option('', '--everything', default=False, action='store_true',
    help='run all tests')

parser.add_option('', '--lvalertMPutils', default=False, action='store_true',
    help='run tests of lvalretMPutils')

parser.add_option('', '--commands', default=False, action='store_true',
    help='run tests of commands')

parser.add_option('', '--parseAlert', default=False, action='store_true',
    help='run tests of parseAlert')

opts, args = parser.parse_args()

opts.verbose = opts.Verbose or opts.verbose

#-------------------------------------------------

if opts.lvalertMPutils or opts.everything:
    if opts.verbose:
        print( 'testing lvalertMPutils' )

    #--- logging
    ### utils.genLogname
    logname = utils.genLogname( 'fakedir', 'faketag' )
    assert isinstance(logname, str), 'lvalertMPutils.genLogname did not return a string'
    assert logname[-4:]=='.log', 'lvalertMPutils.genLogname returned a string that did not end in \".log\"'
    if opts.Verbose:
        print( '    lvalertMPutils.genLogname passed all tests successfully' )

    ### utils.genFormatter
    formatter = utils.genFormatter()
    assert isinstance(formatter, utils.logging.Formatter), 'lvalertMPutils.genFormatter returned the wrong type : %s'%(type(formatter))
    if opts.Verbose:
        print( '    lvalertMPutils.genFormatter passed all tests successfully' )

    #--- Task
    timeout = 10
    kwargs = {'example':'kwarg'}
    logTag = __file__

    ### __init__ (timeout, expiration, kwargs, logTag)
    task = utils.Task(timeout, logTag=logTag, **kwargs)
    assert task.timeout == timeout, 'Task.timeout is not set correctly'
    assert task.expiration == None, 'Task.expiration is not set correctly'
    assert task.logTag == logTag, 'Task.logTag is not set correctly'
    for key, value in kwargs.items():
        assert task.kwargs.has_key(key) and task.kwargs[key]==value, 'Task.kwargs is not set correctly'

    ### __str__
    string = str(task)
    assert task.name in string, 'Task.name not in str(Task)'
    assert task.description in string, 'Task.description not in str(Task)'

    ### setExpiration
    t0 = time.time()
    task.setExpiration(t0)
    assert task.expiration == t0+timeout, 'Task.expiration not set correctly by Task.setExpiration'

    ### hasExpired
    assert not task.hasExpired(), 'task expired too quickly' ### this is a bit fragile because I'm assuming timeout is not too small...
    wait = task.expiration-time.time()
    if opts.Verbose:
        print( '    waiting %.3f seconds so Task can expire'%wait )
    time.sleep(wait)
    assert task.hasExpired(), 'task did not expire quickly enough'

    ### execute (will naturally test Task.task)
    task.execute() ### if this succeeds, then the test succeeds

    if opts.Verbose:
        print( '    lvalertMPutils.Task passed all tests successufully' )

    #--- QueueItem
    t0 = time.time()

    ### __init__ (t0, tasks, completedTasks, complete, expiration, logTag)
    for tasks in [[], [utils.Task(100), utils.Task(10), utils.Task(15), utils.Task(16)]]:
        item = utils.QueueItem(t0, tasks=tasks, logTag=logTag)
        tasks.sort(key=lambda t: t.timeout) ### rearrange this as we expect QueueItem to do
        assert item.t0 == t0, 'lvalertMPutils.QueueItem.t0 not set correctly'
        assert len(item.tasks)==len(tasks), 'QueueItem.tasks not set correctly'
        for task in tasks:
            assert task.expiration == t0+task.timeout, 'QueueItem did not set task\'s expirations correctly'
        assert item.tasks==tasks, 'QueueItem.tasks do not match expected order'
        assert len(item.completedTasks)==0, 'QueueItem.completedTasks not set correctly'
        assert item.complete==(len(tasks)==0), 'QueueItem.complete not set correctly'
        if tasks:
            assert item.expiration==tasks[0].expiration, 'QueueItem.expiration not set correctly'
        else:
            assert item.expiration==-np.infty, 'QueueItem.expiration expiratoin not set correctly when there are no tasks'
        assert item.logTag==logTag, 'QueueItem.logTag not set correctly'

    ### __str__
    string = str(item)
    assert item.name in string, 'QueueItem.name not in str(QueueItem)'
    assert item.description in string, 'QueueItem.description not in str(QueueItem)'

    ### sortTasks
    item.tasks.sort(key=lambda t: t.expiration, reverse=True) ### mess up sorting so we can test this
    item.sortTasks()
    for a, b in zip(item.tasks, tasks):
        assert a==b, 'QueueItem.sortTasks did not produce the proper ordering'

    ### setExpiration
    t0 = time.time()
    completedTasks = [utils.Task(0)]
    for task in completedTasks:
        item.completedTasks.append( task ) ### setExpiration should not touch this
    item.setExpiration(t0)
    assert len(item.tasks)==len(tasks), 'QueueItem.setExpiration modified length of item.tasks'
    for task in item.tasks:
        assert task.expiration==t0+task.timeout, 'QueueItem.setExpiration did not update task.expiration times correctly'
    assert item.expiration == tasks[0].expiration, 'QueueItem.setExpiration dit not update item.expiration corretly'
    assert len(item.completedTasks)==len(completedTasks), 'QueueItem.setExpiration modified length of item.completedTasks'
    assert item.completedTasks==completedTasks, 'QueueItem.setExpiration modified elements of item.completedTasks'
    for task in completedTasks:
        assert task.expiration==None, 'QueueItem.setExpiration modified expiration of elements of item.completedTasks'

    ### hasExpired
    t0 = time.time()
    item.setExpiration(t0)
    assert not item.hasExpired(), 'QueueItem expired too quickly'
    wait = item.expiration-time.time()
    if opts.Verbose:
        print( '    waiting %.3f seconds for QueueItem to expire'%wait )
    time.sleep(wait)
    assert item.hasExpired(), 'QueueItem did not expire quickly enough'

    ### execute (includes updating self.expiration, self.complete, self.tasks, self.completedTasks)
    t0 = time.time()
    item.setExpiration(t0)
    expiration = item.expiration
    item.execute() ### should do nothing 
    assert item.tasks==tasks, 'QueueItem.execute modified item.tasks before it expired'
    assert item.completedTasks==completedTasks, 'QueueItem.execute modified item.completedTasks before it expired'
    assert item.expiration==expiration, 'QueueItem.execute modified item.expiration before it expired'
    assert item.complete==(len(tasks)==0), 'QueueItem.execute modified item.complete before it expired'

    wait = item.expiration-time.time()
    if opts.Verbose:
        print( '    waiting %.3f seconds for QueueItem to expire'%wait )
    time.sleep(item.expiration-time.time())
    item.execute() ### should do something
    assert item.tasks!=tasks, 'QueueItem.execute did not modify tasks as expected'
    assert len(item.tasks)==len(tasks)-1, 'QueueItem.execute did not perform only a single task'
    assert item.completedTasks!=completedTasks, 'QueueItem.execute did not modify completedTasks as expected'
    assert len(item.completedTasks)==len(completedTasks)+1, 'QueueItem.execute did not move only a single task to completedTasks'
    assert item.completedTasks[-1]==tasks[0], 'QueueItem.execute did not perform and move the expected task'
    assert item.expiration!=expiration, 'QueueItem.execute did not modify item.expiration as expected'
    assert item.expiration==item.tasks[0].expiration, 'QueueItem did not modify item.expiration as expected'

    tasks = [task for task in item.tasks] ### create a new list object to avoid shared references
    completedTasks = [task for task in item.completedTasks] ### create a new list object to avoid shared references
    wait = item.tasks[1].expiration-time.time() ### sleep until we've let the next 2 tasks expire
    if opts.Verbose:
        print( '    waiting %.3f seconds for the next 2 Tasks to expire'%wait )
    time.sleep(wait)
    item.execute() ### should peform 2 tasks
    assert len(item.tasks)==len(tasks)-2, 'QueueItem.execute did not peform 2 tasks as expected'
    assert len(item.completedTasks)==len(completedTasks)+2, 'QueueItem.execute did not move 2 tasks as expected'
    assert item.expiration==tasks[2].expiration, 'QueueItem.execute did not update expiration as expected'

    ### add (updating self.tasks and self.expiration)
    tasks = [task for task in item.tasks]
    completedTasks = [task for task in item.completedTasks]
    task = 'cat' ### note, *not* an instance of QueueItem
    try:
        item.add(task)
        raise AssertionError, 'QueueItem.add did not raise a ValueError when supplied a bad data type'
    except ValueError:
        pass
    newTasks = [utils.Task(500), utils.Task(5)]
    newTasks[0].setExpiration(time.time())
    combinedTasks = newTasks + tasks
    combinedTasks.sort(key=lambda t: t.expiration if t.expiration!=None else item.t0+t.timeout) ### sort into the expect format
    taskExpiration = newTasks[0].expiration
    itemExpiration = item.expiration

    item.add(newTasks)
    assert len(item.tasks)==len(combinedTasks), 'QueueItem.add did not insert newTasks correctly'
    assert newTasks[0].expiration==taskExpiration, 'QueueItem.add modified a task\'s expiration when it was already set'
    assert newTasks[1].expiration==item.t0+newTasks[1].timeout, 'QueueItem.add did not set a task\'s expiration when it was not already set'
    
    assert item.expiration==newTasks[1].expiration, 'QueueItem.add did not update item.expiration as it should have'
    assert item.tasks[0]==combinedTasks[0], 'QueueItem.add did not place the expected task in the right place'
    assert not item.complete, 'QueueItem.add modified item.complete unexpectedly'

    item.complete=True
    item.add(utils.Task(np.infty))
    assert not item.complete, 'QueueItem.add did not reset item.complete=False as expected'
    item.tasks.pop(-1) ### remove this so it doesn't mess anything else up

    ### remove (updating self.tasks and self.expiration)
    try:
        item.remove('cat')
        raise AssertionError, 'QueueItem.remove did not raise a KeyError when it was given a TaskName that was not in item.tasks'
    except KeyError:
        pass

    item.remove('task')
    assert len(item.tasks)==len(combinedTasks)-1, 'QueueItem.remove did not modify item.tasks\'s length as expected'
    assert item.completedTasks==completedTasks, 'QueueItem.remove modified completedTasks'
    assert item.expiration==combinedTasks[1].expiration, 'QueueItem.remove did not modify expiration as expected'
    assert not item.complete, 'QueueItem.remove unexpectedly set item.complete=True'

    while len(item.tasks):
        item.remove(item.tasks[0].name)
    assert item.expiration==-np.infty, 'QueueItem.remove did not set expiration to -infty when it ran out of tasks'
    assert item.complete, 'QueueItem.remove did not set item.complet=True when it ran out of tasks'

    if opts.Verbose:
        print( '    lvalertMPutils.Queue passed all tests successufully' )

    #--- SortedQueue

    ### __init__ (__queue__, complete)
    queue = utils.SortedQueue()
    assert queue.__queue__==[], 'SortedQueue.__queue__ was not empty upon instantiation'
    assert queue.complete==0, 'SortedQueue.complete was not instantiated correctly'

    ### __str__
    string = str(queue) ### is this does not raise an error, we pass this test

    ### __iter__
    for item in queue: ### this will ensure the object is iterable
        pass 

    ### __len__
    len(queue) ### this will ensure the object has a __len__

    ### insert (ensure item is a QueueItem, ordering, updating complete)
    item = 'cat'
    try:
        queue.insert( item )
        raise AssertionError, 'SortedQueue.insert did not raise a ValueError when given something besides a QueueItem'
    except ValueError:
        pass
    t0 = time.time()
    items = [
        utils.QueueItem(t0, []), ### expiration will be -np.infty
        utils.QueueItem(t0, [utils.Task(10)]),
        utils.QueueItem(t0, [utils.Task(5)])
    ]
    for item in items:
        queue.insert( item )
    items.sort(key=lambda i:i.expiration)
    assert queue.__queue__==items, 'SortedQueue did not order items correctly'
    assert queue.complete==sum([item.complete for item in items]), 'SortedQueue.insert did not manage queue.complete correctly'

    ### __getitem__
    item = queue[0] ### this ensures the queue has a __getitem__ that behaves like we want
    
    ### pop (__queue__, updating complete)
    complete = queue.complete
    for ind in xrange(len(queue)):
        item = queue[ind]
        assert item==queue.pop(ind), 'SortedQueue.pop did not return the correct item'
        assert queue.complete==complete-item.complete, 'SortedQueue.pop did not manage queue.complete correctly'
        queue.insert( item )
       
    ### resort (__queue__)
    queue.__queue__.append(queue.__queue__.pop(0)) ### intentionally mess up the ordering
    queue.resort()
    for i in xrange(len(queue)-1):
        assert queue[i].expiration<=queue[i+1].expiration, 'SortedQueue.resort did not sort the items correctly'
    assert queue.complete==complete, 'SortedQueue.resort modified queue.complete'

    ### setComplete
    queue.complete += 1 ### intentionally mess this up
    queue.setComplete() 
    assert queue.complete==complete, 'SortedQueue.setComplete did not correctly set queue.complete'
    assert queue.__queue__==items, 'SortedQueue.setComplete messed up queue.__queue__'

    ### clean (__queue__ and complete)
    queue.clean()
    items = [item for item in items if not item.complete]
    for item in queue:
        assert not item.complete, 'SortedQueue.clean did not remove all complete items'
    assert queue.complete==0, 'SortedQueue.clean did not set queue.complete correctly'
    assert queue.__queue__==items, 'SortedQueue.clean did not return the expected list of items'

    if opts.Verbose:
        print( '    lvalertMPutils.Task passed all tests successufully' )

    if opts.verbose:
        print( 'lvalertMPutils passed all tests successfully' )

#------------------------

if opts.commands or opts.everything:
    if opts.verbose:
        print( 'testing commands' )

    #--- CommandTask
    queue = utils.SortedQueue()
    queueByGraceID = dict()
    logTag = 'logTag'

    ### __init__ (queue, queueByGraceID, kwargs with "sleep" as a special case, assertion that we have the right kwargs)
    #       instantiate objects both with and withough sleep kwarg. Then check timeout.
    kwargs = {'nothing':'special'}
    task = commands.CommandTask(queue, queueByGraceID, logTag=logTag, **kwargs)
    assert queue==task.queue, 'CommandTask.queue not stored correctly'
    assert queueByGraceID==task.queueByGraceID, 'CommandTask.queueByGraceID not stored correctly'
    assert task.logTag==logTag, 'CommandTask did not set logTag correctly'
    assert task.kwargs==kwargs, 'CommandTask.kwargs not stored correctly'
    assert task.timeout==-np.infty, 'CommandTask.timeout not set correctly'

    kwargs['sleep'] = 20
    task = commands.CommandTask(queue, queueByGraceID, **kwargs)
    assert task.timeout==kwargs['sleep'], 'CommandTask.timeout not set correctly'

    ### checkKWargs
    task.checkKWargs() ### without an error, this passes

    # add a required kwarg that is not present, check for error
    task.required_kwargs.append('missing')
    try:
        task.checkKWargs()
        raise AssertionError, 'CommandTask.checkKWargs did not raise an error when a required kwarg was missing'
    except KeyError:
        pass

    task.kwargs['missing'] = 'no more'
    task.checkKWargs() ### should not raise an error

    # change requirements so 'missing' is now forbidden
    task.forbidden_kwargs.append(task.required_kwargs.pop())
    try:
        task.checkKWargs()
        raise AssertionError, 'CommandTask.checkKWargs dit not raise an error when a forbidden kwarg was present'
    except KeyError:
        pass

    task.kwargs.pop('missing')
    task.checkKWargs() ### this should now pass

    ### clear out required/forbidden kwargs so we don't mess up things down the line
    task.required_kwargs = []
    task.forbidden_kwargs = []

    ### command
    #       confirm that this runs without raising exceptions 
    task.command() ### this should not raise an error if we are to pass

    if opts.Verbose:
        print( '    commands.CommandTask passed all tests successfully' )

    #--- CommandQueueItem
    fakeid = 'fakeid'

    ### __init__ (graceid, defining tasks, kwargs with "graceid" as a special case)
    t0 = time.time()
    commands.__tid__['command'] = commands.CommandTask
    item = commands.CommandQueueItem(t0, queue, queueByGraceID, logTag=logTag, **kwargs)
    assert item.t0==t0, 'CommandQueueItem.t0 not set correctly'
    assert item.logTag==logTag, 'ComandQueueItem did not set logTag correctly'
    assert not hasattr(item, 'graceid'), 'CommandQueueItem has \'graceid\' attributed when it should not'

    assert (len(item.tasks)==1) and (item.tasks[0].name==item.name), 'CommandQueueItem did not instantiate CommandTask correctly'
    task = item.tasks[0]
    assert (task.queue==queue) and (task.queueByGraceID==queueByGraceID), 'CommandQueueItem\'s task does not contain the correct pointers to queue, queueByGraceID'
    assert task.kwargs==kwargs, 'CommandQueueItem\'s task\'s kwargs is not set correctly'
    assert task.logTag=='%s.%s'%(logTag, item.name), 'CommandQueueItem\'s task\'s logTag not set correctly'

    kwargs['graceid'] = fakeid
    item = commands.CommandQueueItem(t0, queue, queueByGraceID, **kwargs)
    assert hasattr(item, 'graceid') and item.graceid==fakeid, 'CommandQueueItem.graceid is not set correctly'

    if opts.Verbose:
        print( '    commands.CommandQueueItem passed all tests successfully' )

    #--- Command

    command = commands.Command(**kwargs)

    assert command.data['uid']=='command', 'Command.data["uid"] not set correctly'
    assert command.data['alert_type']==item.name, 'Command.data["alert_type"] not set correctly'
    assert command.data['object']==kwargs, 'Command.data["object"] not set correctly'

    ### checkObject

    # check required_kwargs
    commands.CommandTask.required_kwargs.append( 'required' )
    try:
        command.checkObject()
        raise AssertionError, 'Command.checkObject should have raised an error based on a missing required_kwarg'
    except KeyError:
        pass

    command.data['object']['required'] = 'yes, it is'
    command.checkObject()

    # check forbidden kwargs
    commands.CommandTask.forbidden_kwargs.append( 'forbidden' )
    command.checkObject()

    command.data['object']['forbidden'] = 'not allowed'
    try:
        command.checkObject()
        raise AssertionError, 'Command.checkObject should have raised an error based on a present forbidden_kwarg'
    except KeyError:
        pass
    command.data['object'].pop('forbidden')

    ### write
    json_string = command.write() ### should just pass
    alert = json.loads(json_string) ### should also just pass
    assert alert==command.data, 'Command.write did not record Command.data in a recoverable way'

    ### parse
    command.parse(alert) ### should just pass
    alert['alert_type'] = 'nonsense'
    try:
        command.parse(alert)
        raise AssertionError, 'Command.parse should have raised a value error based on alert_type'
    except ValueError:
        pass

    alert = dict(alert.items()) ### create a new object to break shared reference
    alert['object'] = dict(alert['object'].items())

    alert['alert_type'] = command.name
    alert['object']['forbidden'] = 'is back'
    try:
        command.parse(alert)
        raise AssertionError, 'Command.parse should have raised a KeyError through delegation to checkObject'
    except KeyError:
        pass

    ### genQueueItems
    t0 = time.time()
    items = command.genQueueItems(queue, queueByGraceID, t0, logTag=logTag)
    assert len(items)==1, 'too many items generated'
    item = items[0]
    assert item.name==command.name, 'item.name does not agree with command'
    assert item.t0==t0, 'item.t0 not set correctly'
    assert item.logTag==logTag, 'item.logTag not set correctly'
    
    # check for error if command.name is changed
    command.name = 'not real'
    try:
        command.genQueueItems(queue, queueByGraceID, t0, logTag=logTag)
        raise AssertionError, 'Command.genQueueItems should have raised a KeyError based on a bad name'
    except KeyError:
        pass
    command.name = 'command' ### reset this so we don't mess up later instantiations

    # clear these out so we don't mess anything up down the line
    commands.CommandTask.required_kwargs = []
    commands.CommandTask.forbidden_kwargs = []

    if opts.Verbose:
        print( '    commands.Command passed all tests successfully' )

    #--- internal lookup

    ### __cid__, __qid__, __tid__
    cid_keys = commands.__cid__.keys()
    assert cid_keys==commands.__qid__.keys(), '__cid__ and __qid__ have different keys'
    assert cid_keys==commands.__tid__.keys(), '__cid__ and __tid__ have different keys'

    ### initCommand(name, kwargs)
    name = 'not real' ### should not be allowed because I reloaded the module
    kwargs = dict()
    try:
        commands.initCommand(name, **kwargs)
        raise AssertionError, 'initCommands should have raised a KeyError'
    except KeyError:
        pass

    name = 'command'
    command = commands.initCommand(name, **kwargs) ### this should not raise an error, and this should pass

    ### knownCommands
    known = commands.knownCommands()
    assert isinstance(known, list), 'knownCommands did not return a list'
    for name in known:
        assert isinstance(name, str), 'element of knownCommands() was not a string'

    ### requiredKWargs and forbiddenKWargs
    name = 'not real'
    try:
        commands.requiredKWargs( name )
        raise AssertionError, 'requiredKWargs should have raised a KeyError about a bad name'
    except KeyError:
        pass

    try:
        commands.forbiddenKWargs( name )
        raise AssertionError, 'forbiddenKWargs should have raised a KeyError about a bad name'
    except KeyError:
        pass

    name = 'command' 
    required = commands.requiredKWargs( name )
    assert isinstance(required, list), 'requiredKWargs did not return a list'
    assert required==commands.CommandTask.required_kwargs, 'requiredKWargs did not values stored within object'

    forbidden = commands.forbiddenKWargs( name )
    assert isinstance(forbidden, list), 'forbiddenKWargs did not return a list'
    assert forbidden==commands.CommandTask.forbidden_kwargs, 'forbiddenKWargs did not return values stored within object'

    if opts.Verbose:
        print( '    commands internal lookup passed all tests successfully' )

    #--- parseCommand

    t0 = time.time()
    alert = {'uid':'not command', 'alert_type':'not real', 'object':{'graceid':fakeid}}

    try: 
        commands.parseCommand( queue, queueByGraceID, alert, t0, logTag=logTag)
        raise AssertionError, 'parseCommand should have raised a ValueError based on the bad uid'
    except ValueError:
        pass
    alert['uid'] = 'command'

    try:
        commands.parseCommand( queue, queueByGraceID, alert, t0, logTag=logTag)
        raise AssertionError, 'parseCommand should have raised a KeyError from delegation to initCommand'
    except:
        pass
    alert['alert_type'] = 'command'    

    commands.parseCommand(queue, queueByGraceID, alert, t0, logTag=logTag) ### should just work
    assert len(queue)==1, 'queue was not modified correctly'
    item = queue[0]
    assert item.name=='command', 'wrong QueueItem was inserted into queue'
    assert item.expiration==-np.infty, 'Item\'s expiration was not set correctly'
    assert len(queueByGraceID.keys())==1, 'queueByGraceID was not set correctly'
    assert len(queueByGraceID[fakeid])==1, 'queueByGraceID\'s value has the wrong length'
    assert queueByGraceID[fakeid][0]==item, 'queueByGraceID does not reference the same item as queue'

    commands.parseCommand(queue, queueByGraceID, json.loads(commands.Command(sleep=10).write()), t0, logTag=logTag)
    assert len(queue)==2, 'queue was not modified correctly'
    assert len(queueByGraceID.keys())==1, 'queueByGraceID contains an unexpected key'
    assert len(queueByGraceID[fakeid])==1, 'queueByGraceID\'s value was modified unexpected'
    item = queue[1]
    assert item.name=='command', 'wrong type of QueueItem was created'
    assert item.expiration==t0+10, 'item\'s expiration was not set correctly'

    # ensure we get the correct behavior when there are required_kwargs
    commands.CommandTask.required_kwargs.append('required')
    try:
        commands.parseCommand(queue, queueByGraceID, alert, t0, logTag=logTag)
        raise AssertionError, 'should have raised an error about missing kwargs'
    except KeyError:
        pass
    alert['object']['required'] = 'present'
    commands.parseCommand(queue, queueByGraceID, alert, t0, logTag=logTag) ### now should just pass
 
    # ensure we get the correct behavior when there are forbidden_kwargs
    commands.CommandTask.forbidden_kwargs.append('forbidden')
    commands.parseCommand(queue, queueByGraceID, alert, t0, logTag=logTag) ### now should just pass
    alert['object']['forbidden'] = 'present'
    try:
        commands.parseCommand(queue, queueByGraceID, alert, t0, logTag=logTag) ### now should just pass
        raise AssertionError, 'should have raised an error about forbidden kwargs'
    except KeyError:
        pass

    # again, clean these out so I don't mess myself up down the line
    commands.CommandTask.required_kwargs = []
    commands.CommandTask.forbidden_kwargs = []

    if opts.Verbose:
        print( '    commands.parseCommand passed all tests successfully' )

    #--- CommandTask functionality

    q = utils.SortedQueue()
    qbgid = dict()
    t0 = time.time()

    ### raiseException
    try:
        commands.RaiseException().genQueueItems(q, qbgid, t0, logTag=logTag)[0].execute()
        raise AssertionError, 'RaiseException should have raised a RuntimeError'
    except RuntimeError:
        pass

    ### raiseWarning
    try:
        commands.RaiseWarning().genQueueItems(q, qbgid, t0, logTag=logTag)[0].execute()
        raise AssertionError, 'RaiseWarning should have raised a RuntimeWarning'
    except RuntimeWarning:
        pass

    ### clearQueue
    item = utils.QueueItem(time.time(), [utils.Task(np.infty)])
    item.graceid = fakeid
    q.insert(item)
    qbgid[fakeid] = utils.SortedQueue()
    qbgid[fakeid].insert(item)

    cqi = commands.ClearQueue().genQueueItems(q, qbgid, t0, logTag=logTag)[0]
    q.insert(cqi)
    cqi.execute()
    assert len(q)==0, 'queue was not cleaned'
    assert len(qbgid.keys())==0, 'queueByGraceID was not cleaned'

    ### clearGraceID (requires graceid)
    qbgid[fakeid] = utils.SortedQueue()
    qbgid[fakeid].insert(item)

    try:
        commands.ClearGraceID()
        raise AssertionError, 'should have raise a KeyError here'
    except KeyError:
        pass

    cqi = commands.ClearGraceID(graceid=fakeid).genQueueItems(q, qbgid, t0, logTag=logTag)[0]
    q.insert(cqi)
    qbgid[cqi.graceid].insert(cqi)
    cqi.execute()
    assert len(qbgid.keys())==1, 'queueByGraceID was emptied too much'
    assert len(qbgid[fakeid])==1, 'queueByGraceID was emptied too much'
    assert qbgid[fakeid][0]==cqi, 'queueByGraceID did not retain a reference to ClearGraceID item'
    assert cqi.complete, 'ClearGraceID item was not marked complete'
    assert len(q)==1 and q[0]==cqi, 'queue did not retain a reference to ClearGraceID item'

    ### printMessage (requires message)
    logname = os.path.join(opts.logDir, os.path.basename(__file__)+'.log')
    logger = logging.getLogger(logTag)
    logger.setLevel(opts.logLevel)
    logger.addHandler( logging.FileHandler(logname) )
    mtime = os.path.getmtime(logname)

    message = 'hello world'
    commands.PrintMessage(message=message).genQueueItems(q, qbgid, t0, logTag=logTag)[0].execute(verbose=False) ### should just work
    assert mtime<os.path.getmtime(logname), 'log was not modified when it should have been'
    assert message in open(logname,'r').readlines()[-1], 'message was not in the last line of the log'
    mtime = os.path.getmtime(logname)

    ### printQueue (requires filename)
    # NOTE, we don't test the cases where filename='STDOUT' or 'STDERR' here...
    # we also don't check for the content of what's written into the log...
    commands.PrintQueue(filename=logname).genQueueItems(q, qbgid, t0, logTag=logTag)[0].execute() ### should just work
    assert mtime<os.path.getmtime(logname), 'log was not modified when it should have been'    

    ### checkpointQueue (requires filename) and loadQueue (requires filename)
    pklname = os.path.join(opts.logDir, os.path.basename(__file__)+'.pkl')
    commands.CheckpointQueue(filename=pklname).genQueueItems(q, qbgid, t0, logTag=logTag)[0].execute() ### should just work

    # load things from disk using loadQueue
    Q = utils.SortedQueue()
    QBGID = dict()
    commands.LoadQueue(filename=pklname).genQueueItems(Q, QBGID, t0, logTag=logTag)[0].execute() ### should modify Q, QBGID
    assert len(Q)==len(q), 'loaded queue does not match what we wrote to disk'
    for item1, item2 in zip(Q,q):
        assert item1.name==item2.name and item1.expiration==item2.expiration, 'loaded queue does not match what we wrote to disk'
        # NOTE: this could be more thorough...

    assert QBGID.keys()==qbgid.keys(), 'loaded queueByGraceID does not match what we wrote to disk'
    for key in QBGID.keys():
        assert len(QBGID[key])==len(qbgid[key]), 'loaded queueByGraceID does not match what we wrote to disk'
        for item1, item2 in zip(QBGID[key], qbgid[key]):
            assert item1.name==item2.name and item1.expiration==item2.expiration, 'loaded queueByGraceID does not match what we wrote to disk'
            # NOTE: this could be more thorough...

    # now check that we don't overwrite things that are already in queue when we load in stuff
    # NOTE: we don't check that existing items were not modified...

    extraid = 'extraid'
    Q = utils.SortedQueue()
    QBGID = dict([(fakeid,utils.SortedQueue()), (extraid,utils.SortedQueue())])

    item = utils.QueueItem(t0, [])
    item.graceid = fakeid
    Q.insert( item )
    QBGID[fakeid].insert( item )
    commands.LoadQueue(filename=pklname).genQueueItems(Q, QBGID, t0, logTag=logTag)[0].execute() ### should modify Q, QBGID

    assert len(Q)==len(q)+1, 'Q did not have the expected length'
    assert len(QBGID.keys())==2 and QBGID.has_key(fakeid) and QBGID.has_key(extraid), 'QBGID did not have the expected number of keys'
    assert len(QBGID[fakeid])==len(qbgid[fakeid])+1, 'QBGID[fakeid] did not have the correct length'
    assert len(QBGID[extraid])==0, 'QBGID[extraid] did not have the correct length'

    # check that expiration is updated correctly if we supply the sleep kwarg
    timeout = 2
    ckpt = commands.CheckpointQueue(filename=pklname, sleep=timeout).genQueueItems(q, qbgid, t0, logTag=logTag)[0]
    assert ckpt.expiration==t0+timeout, 'expiration was not set correctly'
    if opts.Verbose:
        print( '    sleeping for %d seconds so that call to CheckpointQueueItem.execute does something'%timeout )
    time.sleep(timeout) ### sleep so the item expires and call to execute does something
    t0 = time.time()
    ckpt.execute()
    assert ckpt.expiration > t0+timeout, 'expiration was not updated correctly'
    assert not ckpt.complete, 'complete was not set correctly'

    ### sendEmail (requires recipients, subject, body)
    # tested in lvalert_sanityChecksMP

    if opts.Verbose:
        print( '    commands functionality passed all tests successfully' )

    if opts.verbose:
        print( 'commands passed all tests successfully' )

#------------------------

if opts.parseAlert or opts.everything:
    if opts.verbose:
        print( 'testing parseAlert' )

    #--- PrintAlertTask
    timeout = 10
    fakeid = 'fakeid'
    alert = {'uid':fakeid}
    logTag = __file__

    ### __init__ (graceid, alert)
    task = parseAlert.PrintAlertTask( timeout, fakeid, alert, logTag=logTag )
    assert task.graceid == fakeid, 'task.graceid not set correctly'
    assert task.alert == alert, 'task.alert not set correctly'
    assert task.timeout==timeout, 'timeout not delegated to lvalertMPutils.Task correctly'

    ### printAlert
    logname = os.path.join(opts.logDir, os.path.basename(__file__)+'.log')
    logger = logging.getLogger(logTag)
    logger.setLevel(opts.logLevel)
    logger.addHandler( logging.FileHandler(logname) )
    mtime = os.path.getmtime(logname)

    task.execute() ### should just work
    assert mtime<os.path.getmtime(logname), 'log was not updated when it should have been'
    last_line = open(logname,'r').readlines()[-1]
    assert fakeid in last_line and '%s'%alert in last_line, 'could not find alert printed into log'

    if opts.Verbose:
        print( '    parseAlert.PrintAlertTask passed all tests successfully' )

    #--- parseAlert
    q = utils.SortedQueue()
    qbgid = dict()

    ### instantiation of QueueItem, tasks
    ### queue and queueByGraceID are modified as expected
    t0 = time.time()
    parseAlert.parseAlert(q, qbgid, alert, t0, None, logTag=logTag )
    assert len(q)==1, 'queue has the wrong length'
    assert len(q[0].tasks)==2, 'item.tasks has the wrong length'
    assert len(qbgid.keys())==1 and qbgid.has_key(fakeid), 'queueByGraceID not instantiated correctly'

    if opts.Verbose:
        print( '    parseAlert.parseAlert passed all tests successfully' )

    if opts.verbose:
        print ('parseAlert passed all tests successfully' )
