#!/usr/bin/env python

__usage__ = 'lvalert_sanityChecksMP [--options] email@address.com another@email.org ...'
__description__ = """\
a series of tests that require humans to confirm that they worked. These mostly focus on sending emails or otherwise communicating with the outside world. Email addresses can be supplied as input arguments and we require at least one.

More pointed tests are available within lvlaert_libraryTestsMP
"""
__author__ = "Reed Essick (reed.essick@ligo.org)"

#-------------------------------------------------

from lvalertMP.lvalert import lvalertMPutils as utils
from lvalertMP.lvalert import commands
from lvalertMP.lvalert import interactiveQueue

import os
import getpass
import socket

import logging
import traceback

import time

import json

import multiprocessing as mp
from ConfigParser import SafeConfigParser

from optparse import OptionParser

#-------------------------------------------------

def email_body():
    return """\
This is a test email generated by %(filename)s.
    user : %(user)s
    host : %(host)s
    date : %(date)s\
"""%{'filename':__file__, 'user':getpass.getuser(), 'host':socket.gethostname(), 'date':time.strftime('%c')}

#-------------------------------------------------

parser = OptionParser(usage=__usage__, description=__description__)

### options about verbosity and logging
parser.add_option('-v', '--verbose', default=False, action='store_true')
parser.add_option('-V', '--Verbose', default=False, action='store_true')

parser.add_option('', '--logLevel', default=5, type='int', 
    help='the level of verbosity printed to the log')
parser.add_option('', '--logDir', default='.', type='string',
    help='the directory into which log files will be written')

### options about interactiveQueue kwargs
parser.add_option('', '--maxComplete', default=5, type='int', 
    help='the largest allowable number of complete QueueItems within queue before triggering cleanup')

parser.add_option('', '--maxFrac', default=0.50, type='int',
    help='the largest fraction of QueueItems in queue that can be complete before triggering cleanup') 

parser.add_option('', '--warnThr', default=10, type='int',
    help='the number of QueueItems in queue beyond which we begin sending warnings about the queue\'s size')

parser.add_option('', '--warnDelay', default=30, type='float',
    help='the number of seconds that must ellapse between warnings about queue\'s size')

parser.add_option('', '--maxWarn', default=3, type='int',
    help='the maximum number of warnings about queue\'s size that will be issued')

### options about what to test
parser.add_option('', '--everything', default=False, action='store_true',
    help='run all tests')

parser.add_option('', '--lvalertMPutils', default=False, action='store_true',
    help='run tests of lvalretMPutils')

parser.add_option('', '--commands', default=False, action='store_true',
    help='run tests of commands')

parser.add_option('', '--interactiveQueue', default=False, action='store_true',
    help='run tests of interactiveQueue')

opts, recipients = parser.parse_args()

assert recipients, 'Please supply at least one email address as an input argument\n%s'%usage
recipientsStr = ' '.join(recipients) ### used repeatedly, so only do this once

if not os.path.exists(opts.logDir):
    os.makedirs(opts.logDir)

#-------------------------------------------------

if opts.lvalertMPutils or opts.everything:
    if opts.verbose:
        print( 'testing lvalertMPutils' )

    #--- communication with outside world
    ### sendEmail

    ### set up subject and body of email message
    subject = 'TEST: lvalertMP.lvalert.lvalertMPutils.sendEmail'
    body = email_body()

    ### ensure we get the right type of error when we add in an empty recipient list
    try:
        utils.sendEmail( [], body, subject )
    except Exception as e:
        assert isinstance(e, ValueError), 'unexpected error from sendEmail\n%s'%(traceback.format_exc().strip('\n'))

    ### actually try sending the email
    utils.sendEmail( recipients, body, subject )
    if opts.Verbose:
        print( '    sucessfully sent an email to %s'%recipientsStr )

    #--- finished
    if opts.verbose:
        print( 'lvalertMPutils passed all tests successfully' )

#------------------------

if opts.commands or opts.everything:
    if opts.verbose:
        print( 'testing commands' )

    #--- CommandTask functionality
    ### sendEmail (requires recipients, body, subject)

    ### set up logger so command.sendEmail can write somewhere
    logger = logging.getLogger(__file__)
    logger.setLevel(opts.logLevel)
    logfilename = os.path.join(opts.logDir, __file__+'.log')
    if opts.Verbose:
        print( '    setting up logfile : %s'%logfilename )
    logger.addHandler( logging.FileHandler(logfilename) )
    mtime = os.path.getmtime(logfilename) ### the modification time of this log file

    ### set up object
    command = commands.SendEmailTask(
        queue, 
        queueByGraceID, 
        logTag=__file__, 
        recipients=recipients, 
        subject='TEST: lvalertMP.lvalert.commands.SendEmailTask',
        body=email_body(),
    )

    command.sendEmail(verbose=False) ### send email without printing to logger
    assert mtime==os.path.getmtime(logfilename), 'logfile : %s modified when it should not have been'%logfilename
    if opts.Verbose:
        print( '    successfully sent an email to %s without writing to logfile'%recipientsStr )

    command.sendEmail(verbose=True) ### send email and print to logger
    assert mtime<os.path.getmtime(logfilename), 'logfile : %s was not modified when it should have been'%logfilename
    if opts.Verobse:
        print( '    successfully sent an email to %s and wrote to logfile'%recipientsStr )

    string = 'sending email to %s'%recipients
    file_obj = open(logfilename, 'r')
    last_line = file_obj.readlines()[-1]
    file_obj.close()
    assert string in last_line, '''\
last line of %s does not match expected string:
    last line : %s
    expected  : %s'''%(logfilename, last_line, string)
    if opts.Verobse:
        print( '    last line of logfile matches expectations' )
        
    #--- finsihed
    if opts.verbose:
        print( 'commands passed all tests successfully' )

#------------------------

if opts.interactiveQueue or opts.everything:
    if opts.verbose:
        print( 'testing interactiveQueue' )

    ### set up config files
    if opts.Verbose:
        print( '    setting up config file' )
    config = SafeConfigParser() ### a config file containing the minimum amount of information required
    verbose_filename = os.path.join(opts.logDir, 'verbose_config.ini')
    silent_filename = os.path.join(opts.logDir, 'silent_config.ini')
    email_filename = os.path.join(opts.logDir, 'email_config.ini')

    if opts.Verbose:
        print( '        '+config_filename )
        print( '        '+bad_config_filename )

    ### add in options
    config.set('general', 'process_type', 'invalid')
    config.set('general', 'log_directory', opts.logDir)
    config.set('general', 'log_level', opts.logLevel)

    ### write configs to disk
    for filename in [verbose_filename, silent_filename, email_filename]:
        file_obj = open(filename, 'w')
        config.write(file_obj)
        file_obj.close()

    ### set up log information
    silent_logfilename = utils.genLogname( opts.logDir, 'test_'+os.path.basename(silent_filename)[:-4])
    verbose_logfilename = utils.genLogname( opts.logDir, 'test_'+os.path.basename(verbose_filename)[:-4])
    for filename in [silent_filename, verbose_filename]:
        open(filename, 'w').close() ### touch this file so it exists
    silent_mtime = os.path.getmtime(silent_logfilename)
    verbose_mtime = os.path.getmtime(verbose_logfilename)

    ### set-up multiprocessing connection
    silent_conn1, silent_conn2 = mp.Pipe()
    verbose_conn1, verbose_conn2 = mp.Pipe()
    email_conn1, email_conn2 = mp.Pipe()

    #--- start processes
    # verbose=False
    silent_proc = mp.Process(
        target=interactiveQueue.interactiveQueue, 
        args=(silent_conn2, silent_filename, False, opts.maxComplete, opts.maxFrac, opts.warnThr, [], opts.warnDelay, opts.maxWarn),
    )
    silentproc.start()
    silent_conn2.close()

    # verbose=True
    verbose_proc = mp.Process(
        target=interactiveQueue.interactiveQueue, 
        args=(verbose_conn2, verbose_filename, True, opts.maxComplete, opts.maxFrac, opts.warnThr, [], opts.warnDelay, opts.maxWarn),
    )
    verbose_proc.start()
    verbose_conn2.close()

    # email
    email_proc = mp.Process(
        target=interactiveQueue.interactiveQueue, 
        args=(email_conn2, email_filename, True, opts.maxComplete, opts.maxFrac, opts.warnThr, recipients, opts.warnDelay, opts.maxWarn),
    )
    email_proc.start()
    email_conn2.close()

    #--- reading in config file and setting up logger

    ### ensure we can control when we write to log file
    # verbose=False
    assert silent_mtime==os.path.getmtime(silent_logfilename), 'logfile : %s was modified when it should not have been'%silent_logfilename
    if opts.Verbose:
        print( '    successfully forked interactiveQueue without writing to logfile' )

    # verbose=True
    assert verbose_mtime<os.path.getmtime(verbose_logfilename), 'logfile : %s was not modified when it should have been'%verbose_logfilename
    if opts.Verbose:
        print( '    successfully forked interactiveQueue and watched it write to logfile' )
    verbose_mtime = os.path.getmtime(verbose_logfilename)

    #--- robust against improperly formatted json string
    message = 'bad message format' ### send a bad message

    ### verbose=False
    silent_conn1.send( (message, time.time()) )
    time.sleep(1) ### give process a chance to fall over
    assert silent_proc.is_alive(), 'verbose=False process died when a malformed json package was sent'
    assert silent_mtime==os.path.getmtime(silent_logfilename), 'logfile : %s was modified when it should not be'%silent_logfilename
    if opts.Verbose:
        print( '    verbose=False process did not die when sent a malformed json package' )

    ### verbose=True
    verbose_conn.sent( (messsage, time.time()) )
    time.sleep(1)
    assert verbose_proc.is_alive(), 'verbose=True process died when malformed json package was sent'
    assert verbose_mtime<os.path.getmtime(verbose_logfilename), 'logfile : %s was not modified when it should be'%verbose_logfile
    if opts.Verbose:
        print( '    verbose=True process did not die when sent a malformed json package' )
    verbose_mtime = os.path.getmtime(verbose_logfilename)

    ### email
    email_conn1.send( (message, time.time()) )
    time.sleep(1)
    assert email_proc.is_alive(), 'email process died when we attempted to make parseAlert raise an exception'
    if opts.Verbose:
        print( '    email warning about parsing json packet should have been sent to %s'%recipientsStr )

    #--- logger inheritance -> make sure that PrintAlert modifies the logfile
    randKey = ''.join(random.choice('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789') for _ in xrange(16))
    message = json.dumps({'uid':'test', 'content':randKey})

    # verbose=False
    silent_conn1.send( (message, time.time()) )
    time.sleep(1)
    assert silent_mtime==os.path.getmtime(silent_logfilename), 'logfile : %s was modified when it should not be'%silent_logfile
    if opts.Verbose:
        print( '    verbose=False process did not print anything when parseAlert inserted PrintAlertTasks' )

    # verbose=True
    verbose_conn1.send( (message, time.time()) )
    time.sleep(1)
    assert verbose_mtime<os.path.getmtime(verbose_logfilename), 'logfile : %s was not modified when it should be'%verbose_logfile

    file_obj = open(verbose_logfilename, 'r')
    for line in file_obj:
        if randKey in line:
            break
    else:
        raise AssertionError, 'could not find randKey in verbose=True logfile (randKey was included in the alert packet)'
    file_obj.close()
    if opts.Verbose:
        print( '    verbose=False process printed alert when parseAlert inserted PrintAlertTasks' )
    verbose_mtime = os.path.getmtime(verbose_logfilename)

    #--- sending emails

    ### when parseAlert raises an exception
    message = json.dumps({'format':'bad'}) ### dict does not have a 'uid' key, which will cause lvalertMP.lvalert.parseAlert.parseAlert to raise a KeyError

    # verbose=True
    silent_conn1.send( (message, time.time()) )
    time.sleep(1) ### give the process time to react
    assert silent_proc.is_alive(), 'verbose=True process died when we attempted to make parseAlert raise an exception'
    assert silent_mtime==os.path.getmtime(silent_logfilename), 'logfile : %s was modified when it should not be'%silent_logfilename
    if opts.Verbose:
        print( '    verbose=False process successfully survived parseAlert raising an exception' )

    # verbose=True
    verbose_conn1.send( (message, time.time()) )
    time.sleep(1)
    assert verbose_proc.is_alive(), 'verbose=True process died when we attempted to make parseAlert raise an exception'
    assert verbose_mtime<os.path.getmtime(verbose_logfilename), 'logfile : %s was not modified when it should be'%verbose_logfile

    file_obj = open(verbose_logfilename, 'r')
    for line in file_obj:
        if 'parseAlert raised an exception!' in line:
            break
    else:
        raise AssertionError, 'could not find warning about parseAlert\'s exception in verbose=True logfile'
    file_obj.close()

    if opts.Verbose:
        print( '    verbose=True process successfully survived parseAlert raising an exception and printed a Warning' )
    verbose_mtime = os.path.getmtime(verbose_logfilename)

    # email
    email_conn1.send( (message, time.time()) )
    time.sleep(1)
    assert email_proc.is_alive(), 'email process died when we attempted to make parseAlert raise an exception'
    if opts.Verbose:
        print( '    email warning about parseAlert raising an exception should have been sent to %s'%recipientsStr ) 

    ### when execute raises an exception
    message = commands.RaiseException().write() ### send a command to raise an exception

    # verbose=False
    silent_conn1.send( (message, time.time()) )
    time.sleep(1)
    assert silent_proc.is_alive(), 'verbose=False process died when item.execute raised an exception'
    assert silent_mtime==os.path.getmtime(silent_logfilename), 'logfile : %s was modified when it should not be'%silent_logfilename
    if opts.Verbose:
        print( '    verbose=False process successfully survived item.execute raising an exception' )

    # verbose=True
    verbose_conn1.send( (message, time.time()) )
    time.sleep(1)
    assert verbose_proc.is_alive(), 'verbose=True process died when item.execute raised an exception'
    assert verbose_mtime<os.path.getmtime(verbose_logfilename), 'logfile : %s was not modified when it should be'%verbose_logfile

    file_obj = open(verbose_logfilename, 'r')
    for line in file_obj:
        if 'execute raised an exception!' in line:
            break
    else:
        raise AssertionError, 'could not find warning about item.execute\'s exception in verbose=True logfile'
    file_obj.close()

    if opts.Verbose:
        print( '    verbose=True process successfully survived item.execute raising an exception and printed a Warning' )
    verbose_mtime = os.path.getmtime(verbose_logfilename)

    # email
    email_conn1.send( (message, time.time()) )
    time.sleep(1)
    assert email_proc.is_alive(), 'email process died when item.execute raised an exception'
    if opts.Verbose:
        print( '    email warning about item.execute raising an exception should have been sent to %s'%recipientsStr )

    ### when the queue gets too big

    # send in a bunch of messages, enough to trigger the warning threshold
    for ind in xrange(warnThr+1): ### one more than the wanring threshold
        message = commands.PrintMessage(message='message %d'%ind, sleep=1e6).write() ### sleep for a long time so these message are not printed immediately
        for conn in [silent_conn1, verbose_conn1, email_conn1]:
            conn.send( (message, time.time()) )
        time.sleep(1)

    # verbose=False
    assert silent_proc.is_alive(), 'verbose=False process died when we added a bunch of QueueItems'
    assert silent_mtime==os.path.getmtime(silent_logfilename), 'logfile : %s was modified when it should not be'%silent_logfilename
    if opts.Verbose:
        print( '    verbose=False process survived receiving a bunch of QueueItems' )

    # verbose=True
    assert verbose_proc.is_alive(), 'verbose=True process died when we added a bunch of QueueItems'
    assert verbose_mtime<os.path.getmtime(verbose_logfilename), 'logfile : %s was not modified when it should be'%verbose_logfile

    file_obj = open(verbose_logfilename, 'r')
    for line in file_obj:
        if ('len(queue)' in line) and ('>=' in line) and ('warnThr; emails sent to' in line):
            break
    else:
        raise AssertionError, 'could not find warning about warning based on too many QueueItems in verbose=True logfile'
    file_obj.close()

    if opts.Verbose:
        print( '    verbose=True process successfully survived receiving a bunch of QueueItems and printed a Warning' )
    verbose_mtime = os.path.getmtime(verbose_logfilename)

    # email
    assert email_proc.isAlive(), 'email process died when we added a bunch of QueueItems'
    if opts.Verbose:
        print( '    email warning about too many QueueItems should have been sent to %s'%recipientsStr )

    ### check when queue shrinks again

    # clear the queue's before the final warning is sent
    message = commands.ClearQueue().write()
    for conn in [silent_conn1, verbose_conn1, email_conn1]:
        conn.send( (message, time.time()) )
    time.sleep(1)

    # verbose=False
    assert silent_proc.is_alive(), 'verbose=False process died when queue was emptied'
    assert silent_mtime==os.path.getmtime(silent_logfilename), 'logfile : %s was modified when it should not be'%silent_logfilename
    if opts.Verbose:
        print( '    verbose=False process survived clearing the queue' )

    # verbose=True
    assert verbose_proc.is_alive(), 'verbose=True process died when queue was emptied'
    assert verbose_mtime<os.path.getmtime(verbose_logfilename), 'logfile : %s was not modified when it should be'%verbose_logfile

    file_obj = open(verbose_logfilename, 'r')
    for line in file_obj:
        if ('len(queue)' in line) and ('<=' in line) and ('warnThr; emails sent to' in line):
            break
    else:
        raise AssertionError, 'could not find recovery notice about reduced number of QueueItems in verbose=True logfile'
    file_obj.close()

    if opts.Verbose:
        print( '    verbose=True process successfully survived clearing the queue and printed a Recovery notice' )
    verbose_mtime = os.path.getmtime(verbose_logfilename)

    # email
    assert email_proc.isAlive(), 'email process died when queue was emptied'
    if opts.Verbose:
        print( '    email recovery notice about reduced number of QueueItems should have been sent to %s'%recipientsStr )

    ### ensure the final warning is correctly label

    for ind in xrange(warnThr+1): ### one more than the wanring threshold
        email_conn.send( (commands.PrintMessage(message='another message %d'%ind, sleep=1e6).write(), time.time()) )
        time.sleep(1)

    if opts.Verbose:
        print( '    sleeping until final warning should have been issued' )
    time.sleep(warnDelay*maxWarn+10) 

    if opts.Verbose:
        print( '    %d email warnings, including a \"final\" warning should have been sent to %s. These emails should be roughly spaced by %d seconds'%(maxWarn, recipientStr, warnDelay) )

    #--- garbage collection 

    ### FIXME: 
    ###    how do I check this externally? 
    ###    need to send in things like checkpointQueue and examine by hand (load in the queue.pkl and make assertion statements based on that).

    ### cleaning up empty SortedQueues from queueByGraceID 
    ###     add an item for a particular GraceID. Then ClearGraceID so it is removed from queueByGraceID. Thus, we get an empty queueByGraceID that should be removed
    ###     we can check each point of this process by repeatedly sending in checkpointQueue commands

    ### cleaning up queue when there are too many completed items 
    ###    add a bunch of items for a particular GraceID, then ClearGraceID -> we get complete QI's
    ###    we can check each point of this process by repeatedly sending in checkpointQueue commands

    #--- finsihed
    ### clean up processes
    silent_proc.terminate()
    verbose_proc.terminate()
    email_proc.terminate()

    if opts.verbose:
        print( 'interactiveQueue passed all tests successfully' )
